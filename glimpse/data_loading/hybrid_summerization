def save_dataset(dataset, output_path: Path):
    """
    Save the dataset to a CSV file, ensuring required columns are added or renamed.
    """
    df = dataset.to_pandas()

    # Ensure required columns are present and consistent
    if "index" not in df.columns:
        df["index"] = range(len(df))  # Add an index column if missing

    if "id" not in df.columns:
        df["id"] = df["index"]  # Add an `id` column using the `index` column as fallback

    if "id_candidate" not in df.columns:
        df["id_candidate"] = df.groupby(["index"]).cumcount()

    # Rename columns for consistency
    df.rename(columns={"text": "text", "gold": "gold", "summary": "summary"}, inplace=True)

    # Ensure all required columns are present
    required_columns = ["index", "id", "text", "gold", "summary", "id_candidate"]
    missing_columns = [col for col in required_columns if col not in df.columns]
    if missing_columns:
        raise ValueError(f"Dataset is missing required columns: {missing_columns}")

    # Save the updated dataset
    os.makedirs(output_path.parent, exist_ok=True)
    df.to_csv(output_path, index=False, encoding="utf-8")
    print(f"Saved dataset to {output_path}")


def main():
    args = parse_args()

    # Step 1: Extractive Summarization Phase
    print("Running extractive summarization...")
    dataset = prepare_dataset(args.dataset_path)
    extractive_dataset = extractive_summarizer(dataset)
    save_dataset(extractive_dataset, args.extractive_output_path)

    # Step 2: Prepare Extractive Summaries for Abstractive Phase
    extractive_df = pd.read_csv(args.extractive_output_path)
    if "summary" not in extractive_df.columns:
        raise ValueError("Extractive summary must have a 'summary' column.")
    
    # Ensure proper column naming and drop duplicates
    extractive_df = extractive_df.drop(columns=["text"], errors="ignore")
    extractive_df.rename(columns={"summary": "text"}, inplace=True)
    dataset = Dataset.from_pandas(extractive_df)

    # Step 3: Abstractive Summarization Phase
    print("Running abstractive summarization...")
    abstractive_model = AutoModelForSeq2SeqLM.from_pretrained(args.abstractive_model_name).to(args.device)
    abstractive_tokenizer = AutoTokenizer.from_pretrained(args.abstractive_model_name)
    hybrid_dataset = abstractive_summarizer(
        model=abstractive_model,
        tokenizer=abstractive_tokenizer,
        dataset=dataset,
        decoding_config=args.abstractive_decoding_config,
        batch_size=args.batch_size,
        device=args.device,
    )

    # Step 4: Save Final Hybrid Summaries
    final_output_path = Path(args.output_dir) / f"hybrid_summaries-{datetime.datetime.now():%Y%m%d%H%M%S}.csv"
    save_dataset(hybrid_dataset, final_output_path)
    print(f"Hybrid summarization completed. Results saved to {final_output_path}")


if __name__ == "__main__":
    main()